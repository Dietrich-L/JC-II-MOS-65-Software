;I2C-UTIL.COM -- MOS-65 I2C-Bus UTILITY JC-][ Version
;BY D. LAUSBERG	 (C)2021
;V1.0	03.07.21
;V1.1	08.07.21	BIOS compatibility
;V1.2	10.07.21	BIOS V2.B version
;V1.3	25.03.23	BIOS V3.2 version
;V1.4	11.09.24	JC-][ version
;V1.5	20.11.24	Command G added

VERSION	= $15

;MOS SYSTEM CONSTANTS

BLKB	=  $600		;default buffer

STRBUF	=  $1400

BOOT	=  $2000
TPA	=  $3000

CIN	= $E047
BOUT	= $E044
STRIN	= $E062
STROUT	= $E083
CMDDEV	= $E0BA
OPEN_DEVICE = $E1AA

;SYSTEM CONSTANTS

NUM32	= $F8
PSTR	= $EA
CCPV	= $E0
BLKBUF	= $DC

BUFBEG	= $8000

CMDVEC	= $00
CMDKEY	= $01
PNT	= $02
CNT	= $05
MCNT	= $06
RCOUNT	= $07
BUFFER	= $08
NUMBER	= $0A
HEXL	= $0B
HEXH	= $0C
HEXX	= $0D
DIVL	= $0E
DIVM	= $0F
DIVH	= $10
DRIVE	= $11
INBUF	= $12
IOBASE	= $14		;IO base adress		
CNT1	= $19
MODE	= $1A		;SD Mode byte 0 byte mode; <>0 block mode

DT	= $20		;raw Date&Time info
SEC	= DT
MIN	= DT+1
HOUR	= DT+2
DAY	= DT+3
DD	= DT+4
MM	= DT+5
YY	= DT+6

BEGAD	= $30
ENDAD	= $32
CURAD	= $34
ERRNO	= $36
YBUF	= $37
I2C_DATA = $38		; current I2C data byte
CBUF	= $39		;command Buffer

I2CDEV	= $40		;I2C register cells
ID	= I2CDEV+1
PNT16	= ID+2
ADR	= PNT16+2
ENDADR	= ADR+2

; VIA 2 Register Indices *****************************************************

PORTB	= $10  		; Port B input/output register
DDRB	= $12		; Port B data direction register

;CONTROL CODES

EOT	= $00
BS	= $08
LF	= $0A
CLS	= $0C
CR	= $0D
ESC	= $1B
SPACE	= $20
SEMI	= $3B

;I2C adresses
RTC	= $68
24C32	= $57

;ERROR CODES

NOCOM	= $80
MISPAR	= $81
ILLPAR	= $82
TOOMCH	= $83
EOL	= $84
I2CError = $85
NO_DEV	= $86
M_OVERLAP = $87
ARG0	= $88
EOM	= $89
ID_NFND	= $8A
I2C_FC_ERROR = $8B

	ORG TPA

I2CUTIL	JSR INIT 	;INIT VARIABLES

IUTILL	JSR STATUS
	LDA #PROMPT
	LDY #PROMPT/256
	JSR PRTSTR
	JSR STRIN
	TXA
	LDY #0		;SET COMMAND POINTER
	STA (INBUF),Y	;save string length+1
	STY CMDVEC
IUTIL1	JSR DECODE	;DECODE AND EXEC COMMAND
	BCC IUTIL1
	CMP #EOL 	;END OF COMMAND
	BEQ IUTILL
	JSR ERROR
	JMP IUTILL


INIT	LDA #0		;RESET VARIABLES
	LDX #$13
INIT2	STA $20,X
	STA 0,X
	DEX
	BPL INIT2
	LDA #STRBUF	;set INBUF = STRBUF
	STA INBUF
	LDA #STRBUF/256
	STA INBUF+1
	LDA #BUFBEG	;Set buffer to $8000
	STA BUFFER
	LDA #BUFBEG/256
	STA BUFFER+1
;	LDY #DDRB	; initialize data direction of port B
;	LDA #%01011110	;SDA,/CAS_MOT,/CAS_SENSE,CAS_WR,/SPI_LOAD,SPI_CS,/SND_WE,SCL
;	STA (IOBASE),Y
	JSR I2CCLR	;clear I2C
	RTS


STATUS	LDA #STATM	;DISPLAY STATUS
	LDY #STATM/256
	JSR PRTSTR
	RTS


PRTDEC	JSR COMNUM	;PRINTS DECIMAL
	PHA
	TYA
	JSR COMNUM
	PHA
	TYA
	JSR PRTNUM
	PLA
	JSR PRTNUM
	PLA
	JSR PRTNUM
	RTS


COMNUM	LDY #0		;DIV/10
COMNU1	SEC
	SBC #10
	BCC COMNU2
	INY
	BNE COMNU1

COMNU2	ADC #10
	RTS


PRTNUM	ORA #$30 	;PRINT A NUMBER
	JMP PRTCHR


DECODE	JSR GNCHR	;GET NEXT CHR
	BCS DECODX
	CMP #SEMI	;IS IT A SEPARATOR
	BNE DECOD1
	JSR GNCHR
	BCS DECODX
DECOD1	LDY #0		;SEARCH COMMAND
	STA CMDKEY
DECOD4	LDA CMDTAB,Y
	BEQ DECOD2	;COMMAND NOT FOUND
	CMP CMDKEY
	BEQ DECOD3	;FOUND
	INY
	INY
	INY
	BNE DECOD4

DECOD3	INY
	LDA CMDTAB,Y
	PHA
	INY
	LDA CMDTAB,Y
	PHA
	RTS		;EXEC

DECOD2	LDA #NOCOM	;UNKNOWN COMMAND
	SEC
DECODX	RTS


;==========  COMMANDS  ============= 


TIME	LDA #DT		;get date&time info
	JSR I2CGTIME
	BCS TIMEX	;display Time
	LDA #TIME_M
	LDY #TIME_M/256
	JSR PRTSTR
	LDA HOUR
	AND #$3F	;clear 12/24h & AM/PM bits
	JSR PRTHEX
	LDA #':
	JSR PRTCHR
	LDA MIN
	JSR PRTHEX
	LDA #':
	JSR PRTCHR
	LDA SEC
	JSR PRTHEX
	JSR CRLF	
	CLC
TIMEX	RTS


DATE	LDA #DAY	;get date&time info
	JSR I2CGDATE
	BCS DATEX	;display date
	LDA #DATE_M
	LDY #DATE_M/256
	JSR PRTSTR
	LDA DAY
	JSR Weekday
	LDA DD
	JSR PRTHEX
	LDA #'.
	JSR PRTCHR
	LDA MM
	AND #$7F	;clear century bit
	JSR PRTHEX
	LDA #'.
	JSR PRTCHR
	LDA #$20
	JSR PRTHEX
	LDA YY
	JSR PRTHEX
	JSR CRLF
	CLC
DATEX	RTS


LOAD_ID	JSR GETHEX	;load ID data set to buffer
	BCS LOADIDX
	AND #$7F	;7 bit dev in DT
	STA DT
	JSR GETHEX
	BCS LOADIDX
	STA DT+1	;ID in DT+1
	STY DT+2
LOADID3	LDA BUFFER	;BUFFER in DT+3
	STA DT+3
	LDA BUFFER+1
	STA DT+4
	LDA #DT
;	LDY #C_I2CLOADID
;	JSR JBIOS
LOADIDX	RTS


SET	JSR G1ADR	;Set adr, reg, byte
	BCS SETX
	AND #$7F	;bits 7 must be 0
	STA PNT		;adr
	JSR GETHEX
	BCS SETX
	STA PNT+1	;register byte
	JSR GETHEX
	BCS SETX
	STA PNT+2	;value
	LDA PNT
	JSR I2CADEV	;select dev for Write
	BCS SETX
	LDA PNT+1
	JSR I2CWBYTE	;set register to write
	BCS SETX
	LDA PNT+2
	JSR I2CWBYTE	;write byte to reg
	BCS SETX
	JSR I2CSTOP
SETX	RTS


GET	JSR G1ADR	;Get byte from adr, reg, #
	BCS GETX
	AND #$7F	;bits 7 must be 0
	STA PNT		;adr
	JSR GETHEX
	BCS GETX
	STA PNT+1	;register byte
	JSR GETHEX
	BCS GETX
	STA PNT+2	;#
	LDA PNT
	JSR I2CADEV	;select dev for Write
	BCS GETX
	LDA PNT+1
	JSR I2CWBYTE	;set register to write
	BCS GETX
	LDA PNT
	JSR I2CRDEV	;set device for read
	BCS GETX
GET1	JSR I2CRBYTE	;read byte from reg
	BCS GETX
	JSR PRTHEX	;and print it
	DEC PNT+2
	BEQ GET2
	LDA #',
	JSR PRTCHR
	JSR PRTSP
	JMP GET1
	
GET2	JSR I2CRLB	;read dummy byte
GETX	RTS

READ	JSR G1ADR	;read from adr, reg word,
	BCS READX	;nnnn bytes to buffer
	AND #$7F	;bits 7 must be 0
	STA YBUF	;save dev
	JSR GETHEX
	BCS READX
	STA CURAD	;CURAD = reg
	STY CURAD+1
	JSR GETHEX
	BCS READX
	STA ENDAD
	STY ENDAD+1
	LDA BUFFER	;set PNT & ENDAD
	STA PNT
	ADC ENDAD
	STA ENDAD
	LDA BUFFER+1
	STA PNT+1
	ADC ENDAD+1
	STA ENDAD+1
	JSR R_BLK	;read block
READX	RTS


WRITE	JSR G1ADR	;write to adr, reg word,
	BCS WRITEX	;nnnn bytes from buffer
	AND #$7F	;bits 7 must be 0
	STA YBUF	;save dev
	JSR GETHEX	;get reg
	BCS READX
	STA CURAD
	STY CURAD+1
	JSR GETHEX	;get n
	BCS WRITEX
	STA ENDAD
	STY ENDAD+1
	LDA ENDAD	;check for nnnn = 0
	BNE WRITE1
	LDA ENDAD+1
	BNE WRITE1
	LDA #ARG0	;arg = 0 Error
WRITEX	SEC
	RTS

WRITE1	LDA BUFFER	;set BEGAD & ENDAD
	STA PNT
	ADC ENDAD
	STA ENDAD
	LDA BUFFER+1
	STA PNT+1
	ADC ENDAD+1
	STA ENDAD+1
WRITE2	JSR WPAGE
	RTS


INFO	JSR I2CCLR
	BCS INFOX
	LDA #INFO_M
	LDY #INFO_M/256
	JSR PRTSTR
	LDA #0
	STA YBUF	;start with dev = 0
INFO3	JSR PRT2SP	;print dev adresses
	LDA YBUF
	JSR PRTHEX
	LDA YBUF
	JSR I2CADEV
	BCC INFO1
	LDA #CPOS1
	LDY #CPOS1/256
	JSR PRTSTR
INFO2	INC YBUF
	BPL INFO3
	JSR CRLF	;all adr scanned
	CLC
INFOX	RTS

INFO1	JSR PRT2SP	;print dev adresses
	LDA YBUF
	ASL A
	JSR PRTHEX
	JSR PRT2SP
	LDA YBUF
	SEC
	ROL A
	JSR PRTHEX
	JSR CRLF
	JMP INFO2


SETBUF	JSR GETHEX	;GET BUFFER ADDRESS
	BCS SETBUX
	STY BUFFER+1
	STA BUFFER
SETBUX	RTS


CHANGE	JSR GNCHR	;GET NEXT CHR
	BCS CHANGX
	CMP #'H
	BEQ CHEX
	CMP #'A
	BEQ CASC
	LDA #ILLPAR	;ILLEGAL PARAMETER
CHANGX	SEC
	RTS

CHEX	JSR GETHEX	;GET Memory POINTER
	BCS CHANGX
	STY PNT+1
	STA PNT
CHEX1	JSR GETHEX	;GET HEX VALUE
	BCS CHEX2
	LDY #0
	STA (PNT),Y	;REPLACE
	INC PNT
	BNE CHEX1
	INC PNT+1
	BNE CHEX1
	LDA #TOOMCH	;TOO MUCH PARAMETERS
	SEC
	RTS

CHEX2	CMP #MISPAR
	BNE CHANGX
	CLC
	RTS

CASC	JSR GETHEX	;GET DMA POINTER
	BCS CHANGX
	STY PNT+1
	STA PNT
CASC1	JSR GNCHR	;GET HEX VALUE
	BCS CHANGX
	LDY #0
	STA (PNT),Y	;REPLACE
	INC PNT
	BNE CASC1
	INC PNT+1
	BNE CASC1
	LDA #TOOMCH	;TOO Many PARAMETERS
	SEC
	RTS


DUMP	JSR GETHEX	;DUMP
	STA PNT
	STY PNT+1
	BCC DUMP4
	CMP #MISPAR
	BNE DUMP2	;default is buffer
	LDA BUFFER
	STA PNT
	LDA BUFFER+1
	STA PNT+1
DUMP4	LDA PNT
	AND #$F0
	STA PNT
	JSR GETHEX	;GET 2. PARAMETER
	STA ENDAD
	STY ENDAD+1
	BCC DUMP1
	CMP #MISPAR
	BNE DUMP2
	CLC
	LDA PNT
	ADC #$E0	;14 LINES DEFAULT
	STA ENDAD
	LDA PNT+1
	ADC #0
	STA ENDAD+1
DUMP1	JSR DUMPHE	;PRINT HEADER
DUMP3	JSR DUMPL	;PRINT LINE
	BCC DUMP3
	JSR FIXCUR
DUMPX	RTS

DUMP2	SEC
	RTS


FILL	JSR G1ADR	;FILL MEMORY
	BCS FILLX
	JSR GETHEX	;GET 2. ARGUMENT
	BCS FILLX
	STA ENDAD
	STY ENDAD+1
	JSR GETHEX	;GET BYTE
	BCS FILLX
FILL1	JSR CHKEND
	BCS FILL2
	LDY #0
	STA (PNT),Y
	INC PNT
	BNE FILL1
	INC PNT+1
	BNE FILL1

FILL2	CLC
FILLX	RTS


MOVE	JSR G1ADR	;MOVE TO 1. ARGUMENT
	BCS MOVEX
	JSR GETHEX	;GET 2. ARGUMENT START
	BCS MOVEX
	STA BEGAD
	STY BEGAD+1
	JSR GETHEX	;GET 3. ARGUMENT END
	BCS MOVEX
	STA ENDAD
	STY ENDAD+1
	CPY CURAD+1	;ENDAD<CURAD?
	BCC MOVE1
	CMP CURAD
	BCC MOVE1
	LDA CURAD+1	;BEGAD>CURAD?
	CMP BEGAD+1
	BCC MOVE1
	LDA CURAD
	CMP BEGAD
	BCC MOVE1
	LDA #M_OVERLAP
	RTS

MOVE1	LDA PNT+2
	PHA
	LDA PNT+3
	PHA
	LDY #0
	LDA BEGAD
	STA PNT+2
	LDA BEGAD+1
	STA PNT+3
MOVE2	LDA (PNT+2),Y
	STA (PNT),Y
	LDA PNT+3	;CHECK FOR PNT+2=ENDAD
	CMP ENDAD+1
	BCC MOVE5
	LDA PNT+2
	CMP ENDAD
	BCS MOVE3
MOVE5	INC PNT		;INC PNT
	BNE MOVE4
	INC PNT+1
MOVE4	INC PNT+2	;INC PNT+2
	BNE MOVE2
	INC PNT+3
	JMP MOVE2

MOVE3	PLA		;RESTORE PNT+2
	STA PNT+3
	PLA
	STA PNT+2
	CLC
MOVEX	RTS


EXIT	PLA
	PLA			;back to main loop
	RTS			;return to M/OS-65


HELP	LDA #HELPM
	LDY #HELPM/256
	JSR PRTSTR
	RTS


WAIT	JSR GDEC 		;WAIT NN/10 S
	BCS WAITX
	STA CNT
WAIT3	LDA #10
	STA MCNT 		;100 MS
WAIT2	LDX #78
WAIT1	DEY
	BNE WAIT1
	DEX
	BNE WAIT1
	DEC MCNT
	BNE WAIT2
	DEC CNT
	BNE WAIT3
	CLC
WAITX	RTS


REPEAT	LDA RCOUNT		;REPEAT COMMAND
	BEQ REPEA1
REPEA3	DEC RCOUNT		;ONE MORE TIME
	BEQ REPEA5
	LDA #0
	STA CMDVEC
	CLC
	RTS

REPEA1	JSR GDEC 		;GET NO. OF REPEATS
	BCS REPEA2
	STA RCOUNT
	CMP #0
	BNE REPEA3
	LDA #ILLPAR
REPEA4	SEC
	RTS

REPEA2	CMP #MISPAR
	BNE REPEA4
	LDA #10			;DEFAULT 10 TIMES
	STA RCOUNT
	BNE REPEA3

REPEA5	LDA #EOL
	SEC
	RTS


;======  SUBROUTINES  ============== 

R_BLK	LDA YBUF		;Read Block to Buffer
	JSR I2CADEV	;select dev for Write
	BCS RBLKX
	LDA #CURAD		;set 16 bit reg
	JSR I2CR16
	BCS RBLKX
	LDA YBUF
	JSR I2CRDEV
	BCS RBLKX
RBLK1	JSR CHKEND		;read next byte
	BCS RBLK2
	JSR I2CRBYTE
	BCS RBLKX
	LDY #0
	STA (PNT),Y
	INC PNT
	BNE RBLK1
	INC PNT+1
	BNE RBLK1

RBLK2	JSR I2CRLB		;dummy read last byte
RBLKX	RTS



WPAGE	LDA YBUF		;write 32 byte page
	JSR I2CADEV	;select dev for Write
	BCS WPAGX
	LDA #CURAD		;set 16 bit reg
	JSR I2CR16
	BCS WPAGX
WPAGE1	LDY #0
	LDA (PNT),Y
	JSR I2CWBYTE
	BCS WPAGX
	INC CURAD		;inc CURAD
	BNE WPAGE5
	INC CURAD+1
WPAGE5	INC PNT			;inc PNT
	BNE WPAGE3
	INC PNT+1
WPAGE3	JSR CHKEND		;PNT >= ENDAD
	BCC WPAGE4
	JSR I2CSTOP
	LDA YBUF
	JSR I2CADEV	;wait till ready
WPAGX	RTS

WPAGE4	LDA CURAD
	AND #$1F		;max. 32 bytes
	BNE WPAGE1
	JSR I2CSTOP
	LDA YBUF
	JSR I2CADEV	;wait till ready
	BCC WPAGE
	RTS


ADDHEAD	CLC			;set reg to start of data
	LDA CURAD
	ADC #4			;+header
	STA CURAD
	BCC ADDHDX
	INC CURAD+1
ADDHDX	RTS


LDBUFIND			;Load (BUFFER),Y in A,Y
	LDA (BUFFER),Y
	PHA
	INY
	LDA (BUFFER),Y
	TAY
	PLA
	RTS


WeekDay	AND #$07
	LDY #$FF	;Y is CHR pointer
	TAX		;X is Day Pointer 1..7
	DEX
	BEQ WeekD1
WeekD2	INY
	LDA DAYTAB,Y
	BNE WeekD2
	DEX
	BNE WeekD2

WeekD1	INY
	LDA DAYTAB,Y
	BEQ WeekD3
	JSR PRTCHR
	JMP WeekD1

WeekD3	LDA #DAYM
	LDY #DAYM/256
	JSR PRTSTR
	RTS


DUMPHE	JSR PRTPC	;PRINT PC
	LDA #':
	JSR PRTCHR
	JSR PRTSP
	RTS


PRTPC	JSR CRLF
	LDA PNT+1
	JSR PRTHEX
	LDA PNT
	JSR PRTHEX
	RTS


DUMPL	JSR CRLF
	LDY #0
DUMPL1	LDA (PNT),Y
	JSR DISHEX
	INY
	CPY #8
	BNE DUMPL3
	LDA #BS
	JSR PRTCHR
DUMPL3	CPY #$10
	BCC DUMPL1
	LDY #0
DUMPL2	LDA (PNT),Y
	JSR DISASC
	INY
	CPY #$10
	BCC DUMPL2
	TYA
	JSR JNEXT
	JSR CHKEND
	RTS


CHKEND	LDY PNT+1
	CPY ENDAD+1
	BCC CHKENX
	LDY PNT
	CPY ENDAD
CHKENX	RTS


JNEXT	CLC		;JUMP TO NEXT ITEM
	ADC PNT
	STA PNT
	BCC JNEXTX
	INC PNT+1
JNEXTX	RTS


FIXCUR	LDA PNT
	STA CURAD
	LDA PNT+1
	STA CURAD+1
	CLC
	RTS


DISHEX	JSR PRTHEX	;DISPLAYS A HEX
	LDA #SPACE
	JSR PRTCHR
	RTS


DISASC	AND #$7F
	CMP #$20
	BCC DISAS1
	CMP #$7F
	BCC DISAS2
DISAS1	LDA #'.
DISAS2	JSR PRTCHR
	RTS


G1ADR	JSR GETHEX
	BCC G1ADR1
	CMP #MISPAR
	BNE G1ADR2
	LDA CURAD
	LDY CURAD+1
G1ADR1	STA PNT
	STA CURAD
	STY PNT+1
	STY CURAD+1
	CLC
	RTS

G1ADR2	SEC
	RTS


GDEC	JSR GETHEX		;GETS A DECIMAL FROM LINE
	BCS GDECX
	AND #$0F
	CMP #10
	BCS GDEC1
	STA NUMBER		;EINER
	LDA HEXL
	AND #$F0
	LSR A			;ZEHNER*8
	PHA
	CLC
	ADC NUMBER
	STA NUMBER
	PLA
	LSR A
	LSR A			;ZEHNER*2
	CLC
	ADC NUMBER
	CPY #3			;Y= HEXH
	BCS GDEC1
GDEC5	DEY
	BMI GDEC4
	ADC #100
	BCC GDEC5
GDEC1	LDA #ILLPAR
	SEC
GDECX	RTS

GDEC4	STA NUMBER
	CLC
	RTS


GETHEX	LDA #0			;GET HEX NUMBER FROM LINE
	STA HEXL 		;RESET HEX
	STA HEXH
	TAX
GETHE2	JSR GETNIB		;GET NIBBLE TO HEX
	BCS GETHE1
	INX
	CPX #5
	BCC GETHE2
GETHE5	LDA #ILLPAR		;ILLEGAL PARAMETER
	SEC
	RTS

GETHE1	CPX #0
	BNE GETHE3
	CMP #SPACE
	BEQ GETHE2
	CMP #EOL
	BEQ GETHE6
	CMP #SEMI
	BNE GETHE5
GETHE6	LDA #MISPAR
	SEC
	RTS

GETHE3	CMP #SEMI
	BEQ GETHE4
	CMP #',
	BEQ GETHE4
	CMP #EOL
	BNE GETHE5
GETHE4	LDA HEXL
	LDY HEXH
	CLC
	RTS


GETNIB	JSR GNCHR		;GET NIBBLE TO HEX
	BCS GETNIX
	CMP #'0
	BCC GETNI1
	CMP #$3A
	BCC GETNI2
	CMP #'A
	BCC GETNI1
	CMP #'G
	BCC GETNI3
GETNI1	SEC
GETNIX	RTS

GETNI3	CLC
	ADC #9
GETNI2	AND #$0F
	LDY #4
GETNI4	ASL HEXL
	ROL HEXH
	ROL HEXX
	DEY
	BNE GETNI4
	ORA HEXL
	STA HEXL
	CLC
	RTS


GNCHR	LDY #0
	INC CMDVEC
	LDA CMDVEC
	CMP (INBUF),Y
	BCS GNCHRX
	TAY
	LDA (INBUF),Y
	JSR UPCASE
	CLC
	RTS

GNCHRX	LDA #EOL
	RTS


UPCASE	CMP #'a			;LOWER --> UPPER CASE
	BCC UPCASX
	CMP #'~
	BCS UPCASX
	AND #$5F
UPCASX	RTS

;--- JC-][ SPI BIOS  ---
;I2C commands

;C_I2CLOADID	= $1D		not implemented
; *****************************************************************************
; START OF I2C CODE
; *****************************************************************************
;--------- I2C Commands ------------------------------

I2CCLR	JSR I2CStop	;clear I2C-Bus
	JSR I2CStart
	JSR DUP
	LDX #9		;dummy read 9 bits
CLR1	JSR CLK
	DEX
	BNE CLR1
	JSR I2CStart
	JMP I2CStop


I2CADEV	ASL A		;send 7 bit dev adr to write
	STA CBUF
	LDY #20		;try 20 times
	STY CNT1

ADEV1	JSR I2CSTART
	LDA CBUF
	JSR I2CWByte	;addres device
	BCC ADEVX
	DEC CNT1
	BNE ADEV1
	LDA #NO_DEV	;device busy or not present
ADEVX	RTS


I2CR16	TAY		;send word L/H in ZP,A to dev
	LDA $00,Y
	PHA
	INY
	LDA $00,Y
	JSR I2CWByte	;send high byte
	PLA
	BCS R16X	;send low byte
	JSR I2CWByte
R16X	RTS


I2CRDEV			;send 7 bit dev adr to read
	SEC
	ROL A		;set for read
	TAX
	JSR I2CSTART
	TXA
	JSR I2CWByte
	RTS

I2CWByte		;write byte in A to dev
	STA I2C_DATA	;Y to save A
	JSR DDN
	JSR CLKDN
	LDX #8		;send 8 bit
WByte2	JSR DUP
	ASL I2C_DATA	;bit in C
	BCS WByte1
	JSR DDN		;if C=0
WBYTE1	JSR CLK
	DEX
	BNE WByte2
	JMP IS_ACK


I2CRBYTE		;read byte from dev
	JSR I2CRB	;read 1 byte
	JSR I2CACK
	LDA I2C_DATA
	CLC		;Byte in A
	RTS

I2CRLB			;read last byte from dev
	JSR I2CRB	;read 1 byte
	JSR I2CNAK	;send NAK to terminate
	JSR I2CSTOP	
	LDA I2C_DATA
	CLC		;Byte in A
	RTS


I2CGTIME		;get time to p.00 cells
	STA ID+1
	LDA #2		;sec, min, hour
	STA ID
	JMP I2CGTD

I2CGDATE		;get date to p.00 cells
	STA ID+1
	LDA #3		;day, dd, mm, yy
	STA ID

I2CGTD	LDA #RTC	;X pointer, ID nr of bytes-1
	JSR I2CADEV
	BCS I2CGTX
	LDA #0		;reg = 0 (time)
	LDX ID
	CPX #3
	BNE I2CGT3
	TXA		;reg = 3	
I2CGT3	JSR I2CWByte
	BCS I2CGTX
	LDA #RTC	;read command
	JSR I2CRDEV
	BCS I2CGTX
I2CGT1	JSR I2CRBYTE
	BCS I2CGTX
	LDX ID+1
	STA 0,X
	INC ID+1
	DEC ID
	BNE I2CGT1
	JSR I2CRLB
	LDX ID+1
	STA 0,X
I2CGTX	RTS

; I2C subroutines

I2CRB	LDA #0		; set save byte
	STA I2C_DATA
	JSR DUP
	LDX #8		;read 8 Bit
RByte1	JSR CLKUP	;SCL = 1
	JSR DIN		;read 1 bit in C
	ROL I2C_DATA	;shift byte one bit left. C goes into LSB
	JSR CLKDN	;SCL = 0
	DEX
	BNE RBYTE1
	RTS		;byte in Y


; basic I2C states

I2CStart		;I2C start condition
	JSR DUP
	JSR CLKUP
	JSR DDN
	JSR CLKDN
	RTS

I2CStop			; I2C stop condition
	JSR DDN
	JSR CLKUP
	JSR DUP
	CLC
	RTS

I2CACK	JSR DDN		; Master sends ACK
	JSR CLK
	JSR DUP		; release SDA
	RTS

I2CNAK	JSR DUP		; Master sends NAK
	JSR CLK
	RTS

IS_ACK	JSR DUP		;Check for ACK from dev
	JSR CLKUP
	JSR DIN		;ACK bit in C
	JSR CLKDN
	RTS		; C=0 is ACK

; Bit I/O for I2C  PB7 = SDA, PB0 = SCL

DUP	LDY #DDRB
	LDA (IOBASE),Y	;SDA = 1
	AND #%01111111
	STA (IOBASE),Y
	RTS

DDN	LDY #DDRB
	LDA (IOBASE),Y	;SDA = 0
	ORA #%10000000
	STA (IOBASE),Y
	RTS

DIN	LDY #DDRB	; read 1 bit in C
	LDA (IOBASE),Y
	AND #%01111111	;SDA is input
	STA (IOBASE),Y
	LDY #PORTB
	LDA (IOBASE),Y
	ASL A		;Bit 7 is in C
	RTS

CLK	LDY #DDRB
	LDA (IOBASE),Y
	AND #%11111110	; SCL = 1
	STA (IOBASE),Y
	ORA #%00000001	; SCL = 0
	STA (IOBASE),Y
	RTS

CLKUP	LDY #DDRB
	LDA (IOBASE),Y	; SCL = 1
	AND #%11111110
	STA (IOBASE),Y
	RTS

CLKDN	LDY #DDRB
	LDA (IOBASE),Y	; SCL = 0
	ORA #%00000001
	STA (IOBASE),Y
	RTS



;--------------------------------

ERROR	STA ERRNO		;ERROR ROUTINE
	JSR I2CCLR			;clear I2C
	JSR CRLF
	LDA #ERRTAB		;SET CCPV
	STA CCPV
	LDA #ERRTAB/256
	STA CCPV+1
	LDY #0			;CHECK ERROR CODE
	LDA (CCPV),Y
ERROR1	BEQ ERROR4		;END OF ERROR ROUTINE
	CMP ERRNO
	BEQ ERROR3
ERROR2	JSR INCCPV		;SKIP ERROR MESSAGE
	BNE ERROR2
	JSR INCCPV
	JMP ERROR1

ERROR3	JSR INCCPV
	PHA
	JSR ERRTYP		;PRINT ERROR TYPE
	JSR INCCPV
	LDA CCPV 		;PRINT ERROR MESSAGE
	LDY CCPV+1
	JSR PRTSTR
	PLA
	BPL ERROR5
	JSR ASKRTY		;ASK FOR RETRY
	LDA ERRNO
	RTS

ERROR4	JSR UETYP		;UNKNOWN ERROR
ERROR5	SEC
	RTS


ERRTYP	LDY #0			;PRINT ERROR TYPE
ERRTY1	LSR A			;SHIFT SOURCE BIT IN C
	BCS ERRTY2
	INY			;X= X+5
	INY
	INY
	INY
	INY
	BNE ERRTY1

ERRTY2	LDA ETYPTB,Y
	BEQ UETYP		;LAST CHR?
	JSR PRTCHR
	INY
	BNE ERRTY2

UETYP	LDA #ERRM1
	LDY #ERRM1/256
	JSR PRTSTR
	LDA ERRNO
	JSR PRTHEX

CRLF	LDA #CRLFM		;PRINTS A NEWLINE
	LDY #CRLFM/256

PRTSTR	STA PSTR		;print string EOSZ
	STY PSTR+1
	LDY #0
PRTSTR1	LDA (PSTR),Y
	BEQ PRTSTRX		;$00 reached?
	JSR BOUT
	INY
	BNE PRTSTR1
	INC PSTR+1
	BNE PRTSTR1

PRTSTRX	CLC
	RTS


PRT2SP	JSR PRTSP

PRTSP	LDA #SPACE

PRTCHR	JMP BOUT		;PRINTS A CHR
	


INCCPV	INC CCPV 		;INC CCPV
	BNE INCCP1
	INC CCPV+1
INCCP1	LDA (CCPV),Y
	RTS


ASKRTY	LDA #RTYMES		;RETRY?
	LDY #RTYMES/256
	JSR PRTSTR
	JSR CIN
	JSR UPCASE
	CMP #'Y
	BNE ASKRT1
	CLC
	RTS

ASKRT1	SEC
	RTS


PRTHEX	PHA			;PRINTS A HEX NUMBER
	LSR A
	LSR A
	LSR A
	LSR A
	JSR PRTNIB		;PRINT NIBBLE
	PLA
	AND #$0F

PRTNIB	CMP #$0A
	BCC PRTNI1
	ADC #6
PRTNI1	ADC #$30
	JSR PRTCHR
	RTS

;--------- Tables -------

CMDTAB	DB 'Z'
	DD TIME-1
	DB 'K'
	DD DATE-1
;	DB 'L'
;	DD LOAD_ID-1
	DB 'S'
	DD SET-1
	DB 'G'
	DD GET-1
	DB 'R'
	DD READ-1
	DB 'W'
	DD WRITE-1
	DB 'B'
	DD SETBUF-1
	DB 'C'
	DD CHANGE-1
	DB 'F'
	DD FILL-1
	DB 'M'
	DD MOVE-1
	DB 'D'
	DD DUMP-1
	DB 'I'
	DD INFO-1
	DB 'X'
	DD EXIT-1
	DB '?'
	DD HELP-1
	DB 'Z'
	DD WAIT-1
	DB '/'
	DD REPEAT-1

	DB $00

ERRM1	DB ' Error $',EOT
RTYMES	DB CR,LF,'Retry	(Y/N) ? ',EOT

ETYPTB	DB 'BIOS',$00,'BDOS',$00,'CCP',$00,$00
	DB 'RSX',$00,$00,'USER',$00

ERRTAB	DB $F9,$01,'Invalid Drive',EOT
	DB $DE,$82,'Directory full',EOT
	DB $DD,$82,'File not found',EOT
	DB $DC,$02,'File exists',EOT
	DB $D9,$02,'Invalid FCB',EOT
	DB $D8,$82,'Disk full',EOT
	DB $D6,$82,'File is R/O',EOT
	DB $8B,$10,'I2C illegal function call',EOT
	DB $8A,$10,'ID not found',EOT
	DB $88,$10,'Argument = 0',EOT
	DB $87,$10,'Address overlap in move',EOT
	DB $86,$10,'Device not responding', EOT
	DB $85,$10,'I2C Bus Error',EOT
	DB $84,$10,'End of Line',EOT
	DB $83,$10,'Too Much Parameters',EOT
	DB $82,$10,'Illegal Parameter',EOT
	DB $81,$10,'Missing Parameter',EOT
	DB $80,$10,'Unknown Command',EOT

	DB $00

DAYTAB	DB 'Montag',EOT,'Dienstag',EOT,'Mittwoch',EOT,'Donnerstag',EOT
	DB 'Freitag',EOT,'Samstag',EOT,'Sonntag',EOT
DAYM	DB ', den ',EOT


STATM	DB CR,LF,'I2C-Utility	V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30, EOT

PROMPT	DB CR,LF,'Command >',EOT

CRLFM	DB '     ',CR,LF,EOT
CPOS1	DB CR,EOT	;cursor to col 1

TIME_M	DB CR,LF,' Uhrzeit: ',EOT

DATE_M	DB CR,LF,'   Datum: ', EOT

INFO_M	DB CR,LF,' I2C devices active',CR,LF
	DB ' dev   W   R',CR,LF,EOT

HELPM	DB CLS,'   I2C-Utility V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
	DB '			(c) 3.7.2021',CR,LF
	DB 'Command Summary:',CR,LF
	DB ' K	display date	         '
	DB ' Z	 display time',CR,LF
;	DB ' Ldv,iiii  load ID data set from dev to buffer',CR,LF
	DB ' Baddr  set buffer to addr   '
	DB ' Sdv,rg,by  set dev, reg, byte',CR,LF
	DB ' Gdv,rg,nn  get nn bytes from dev, reg ',CR,LF
	DB ' Rdv,regw,nnnn  read from dev, reg16, nnnn bytes to buffer',CR,LF
	DB ' Wdv,regw,nnnn  write to  dev, reg16, nnnn bytes from buffer',CR,LF
	DB ' CHad,by,by,...	change value at ad with by',CR,LF
	DB ' CAad,<string>	change at ad with string',CR,LF
	DB ' Mn,m,j     move to n from m,j',CR,LF
	DB ' Dnnnn,mmmm	dump memory	 '
	DB ' Fnnnn,mmmm,cc fill memory',CR,LF
	DB ' I  info I2C devs active     '
	DB ' /nn repeat nn times',CR,LF
	DB ' ?	prints this screen	 '
	DB ' ',SEMI,'	command separator',CR,LF
	DB ' X	exit to CP/M		 ',CR,LF
	DB EOT


	END
