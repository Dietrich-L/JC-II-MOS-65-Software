;SD-UTIL.COM -- CP/M-65 SD UTILITY JC II M/OS-65 Version
;BY D. LAUSBERG	 (C)1988
;V1.0	13.06.24
;V1.1	06.07.24	;display partition info

VERSION	= $11

;SYSTEM CONSTANTS

NUM32	=  $F8

PSTR	=  $EA
INBUF	=  $12
CCPV	=  $E0
BLKBUF	=  $DC

BLKB	=  $600		;default buffer

STRBUF	=  $1400

BOOT	=  $2000
TPA	=  $3000

BUFBEG	=  $8000


CIN	= $E047
COUT	= $E052
STRIN	= $E062
STROUT	= $E083
CMDDEV	= $E0BA
OPEN_DEVICE = $E1AA

; Device Command Constants ****************************************************

CMD_READ_BUF = 37
CMD_WRITE_BUF = 38

;Zero Page adresses

CMDVEC	= $00
CMDKEY	= $01
PNT	= $02
CNT	= $03
MCNT	= $04
RCOUNT	= $05
BUFFER	= $08
NUMBER	= $0A
HEXL	= $0B
HEXH	= $0C
HEXX	= $0D
HEXY	= $0E
DIVL	= $0F
DIVM	= $10
DIVH	= $11

IOBASE	= $14		;I/O-card base address

MODE	= $1A		;SD Mode byte 0 byte mode; <>0 block mode

ERRNO	= $21
SEC	= $22

LBA	= $28		;current LBA
DIR_NP	= $2C		;pointer to nr of dir entry
DIR_FNP	= $2E		;dir filename pointer
IMAGE	= $30		;image to be mounted - Drive, LBA
CNT_I	= $35		;# images found
CNT_Y	= $36		;counter
BASE	= $37		;LBA of 1. dir sector/1. data sector - 2 cluster
NFAT	= $3B
SEC_CLUS = $3D
NDIR	= $3E
N32	= $40		;32 bit argument
P_BASE	= $44		;partition base
P_LEN	= $48		;partition length
MEDIA_BYTE = $4C	;media byte
FAT_TYPE = $4D		;FAT type
RES_SEC	= $4E		;reserved sectors
FAT_LEN	= $50		;FAT length
FAT_BASE = $54		;FAT base
NFAT_B	= $59		;# FATs


;Parameters

MAX_IMG	= $7F

;BDOS COMMANDS

GETLIN	= $0A

;CONTROL CODES

EOT	= $00
BS	= $08
LF	= $0A
CLS	= $0C
CR	= $0D
SPACE	= $20
SEMI	= $3B

;ERROR CODES

EOF	= $1A

NOCOM	= $80
MISPAR	= $81
ILLPAR	= $82
TOOMCH	= $83
EOL	= $84
INVDRV	= $85
WRT_PROT = $86
SD_CHNG	= $87
NO_SD	= $88
NO_PART	= $89
TM_IMG	= $8A		;too many image files
NO_IMG	= $8B		;no image available

	ORG TPA

DUTIL	JSR INIT 		;INIT VARIABLES

DUTILL	JSR STATUS
	LDX #PROMPT
	LDY #PROMPT/256
	JSR PRTSTR
	JSR STRIN
	STX STRBUF		;save string length+1
	LDY #0			;SET COMMAND POINTER
	STY CMDVEC
DUTIL1	JSR DECODE		;DECODE AND EXEC COMMAND
	BCC DUTIL1
	CMP #EOL 		;END OF COMMAND
	BEQ DUTILL
	JSR ERROR
	JMP DUTILL


INIT	LDX #BANNER
	LDY #BANNER/256
	JSR PRTSTR
	LDA #0			;RESET VARIABLES
	LDX #$13
INIT2	STA 0,X
	DEX
	BPL INIT2
	LDA #STRBUF		;set INBUF = STRBUF
	STA INBUF
	LDA #STRBUF/256
	STA INBUF+1
	LDA #BUFBEG		;SET BUFFER VECTOR
	STA BUFFER
	LDA #BUFBEG/256
	STA BUFFER+1
	JSR SET_BLK		;set BLKBUF to BLKB
	JSR DRVPAR		;GET DRIVE PARAM'S
	JSR READS		;read sector 0
	BCS INIT1
	RTS

INIT1	JSR ERROR
	BCC INIT
	JMP BOOT		;exit


DRVPAR	LDA #0			;RESET VARIABLES
	STA LBA
	STA LBA+1
	STA LBA+2
	STA LBA+3
	RTS


SET_BLK	LDA #BLKB		;set BLKBUF
	STA BLKBUF
	LDA #BLKB/256
	STA BLKBUF+1
	RTS


STATUS	LDX #STATM1		;DISPLAY STATUS
	LDY #STATM1/256
	JSR PRTSTR

	LDX #STATM3
	LDY #STATM3/256
	JSR PRTSTR
	LDX #3
STATUS2	LDA LBA,X
	JSR PRTHEX		;PRINT HEX VALUE
	DEX
	BPL STATUS2
	RTS


PRTDEC	JSR COMNUM		;PRINTS DECIMAL
	PHA
	TYA
	JSR COMNUM
	PHA
	TYA
	JSR PRTNUM
	PLA
	JSR PRTNUM
	PLA
	JSR PRTNUM
	RTS


COMNUM	LDY #0			;DIV/10
COMNU1	SEC
	SBC #10
	BCC COMNU2
	INY
	BNE COMNU1

COMNU2	ADC #10
	RTS


PRTNUM	ORA #$30 		;PRINT A NUMBER
	JMP PRTCHR


DECODE	JSR GNCHR		;GET NEXT CHR
	BCS DECODX
	CMP #SEMI		;IS IT A SEPARATOR
	BNE DECOD1
	JSR GNCHR
	BCS DECODX
DECOD1	LDY #0			;SEARCH COMMAND
	STA CMDKEY
DECOD4	LDA CMDTAB,Y
	BEQ DECOD2		;COMMAND NOT FOUND
	CMP CMDKEY
	BEQ DECOD3		;FOUND
	INY
	INY
	INY
	BNE DECOD4

DECOD3	INY
	LDA CMDTAB,Y
	PHA
	INY
	LDA CMDTAB,Y
	PHA
	RTS			;EXEC

DECOD2	LDA #NOCOM		;UNKNOWN COMMAND
	SEC
DECODX	RTS

CMDTAB	DB 'L'
	DD LBARD-1
	DB 'D'
	DD DUMP-1
	DB 'C'
	DD CHANGE-1
	DB '+'
	DD PLUS-1
	DB '-'
	DD MINUS-1
	DB 'R'
	DD READS-1
	DB 'W'
	DD WRITES-1
	DB 'P'
	DD PARTD-1
	DB 'X'
	DD EXIT-1
	DB '?'
	DD HELP-1
	DB 'Z'
	DD WAIT-1
	DB '>'
	DD STOBUF-1
	DB '<'
	DD STODMA-1
	DB '/'
	DD REPEAT-1
	DB 'B'
	DD SETBUF-1

	DB $00

;==========  COMMANDS  ============= 


LBARD	JSR GETLBA		;GET LBA
	BCS LBARDX
	JSR READS		;READ SECTOR
LBARDX	RTS

LBARD1	LDA #ILLPAR		;LBA > 2 TB
	SEC
	RTS


DUMP	JSR STATUS		;DUMP BLKBUF
	JSR SET_BLK
	LDA #0
	STA PNT			;SET POINTER
	STA CNT
	INC CNT
	JSR CRLF
	LDY PNT
DUMP1	LDA (BLKBUF),Y
	JSR DISHEX
	INY
	TYA
	AND #$0F
	BNE DUMP1
	LDY PNT
DUMP2	LDA (BLKBUF),Y
	JSR DISASC
	INY
	TYA
	AND #$0F
	BNE DUMP2
	JSR CRLF
	STY PNT
	TYA
	BNE DUMP1
	INC BLKBUF+1		;Page 2
	JSR CRLF
	DEC CNT
	BPL DUMP1
	CLC
	RTS


CHANGE	JSR SET_BLK
	JSR GNCHR		;GET NEXT CHR
	BCS CHANGX
	CMP #'H
	BEQ CHEX
	CMP #'A
	BEQ CASC
	LDA #ILLPAR		;ILLEGAL PARAMETER
CHANGX	SEC
	RTS

CHEX	JSR GETHEX		;GET DMA POINTER
	BCS CHANGX
	STA PNT
	LDA HEXL+1		;check for upper page
	BEQ CHEX1
	CMP #1
	BNE CHEX3
	INC BLKBUF+1
CHEX1	JSR GETHEX		;GET HEX VALUE
	BCS CHEX2
	LDY PNT
	STA (BLKBUF),Y		;REPLACE
	INC PNT
	BNE CHEX1
	LDA #TOOMCH		;TOO Many PARAMETERS
	SEC
	RTS

CHEX2	CMP #MISPAR
	BNE CHANGX
	CLC
	RTS

CHEX3	LDA #ILLPAR
	SEC
	RTS

CASC	JSR GETHEX		;GET DMA POINTER
	BCS CHANGX
	STA PNT
	LDA HEXL+1		;check for upper page
	BEQ CASC1
	CMP #1
	BNE CHEX3		;invalid parameter
	INC BLKBUF+1
CASC1	JSR GNCHR		;GET HEX VALUE
	BCS CHANGX
	LDY PNT
	STA (BLKBUF),Y		;REPLACE
	INC PNT
	BNE CASC1
	LDA #TOOMCH		;TOO MUCH PARAMETERS
	SEC
	RTS


PLUS	LDX #0
PLUS2	INC LBA,X
	BNE PLUS1
	INX
	CPX #4
	BCC PLUS2
PLUS1	JSR READS
	RTS


MINUS	LDX #0
MINUS2	DEC LBA,X
	LDA LBA,X
	CMP #$FF
	BNE MINUS1
	INX
	CPX #4
	BCC MINUS2
MINUS1	JSR READS
	RTS


READS	JSR SET_BLK
	LDX #LBA		;load LBA to BLKBUF
	LDY #LBA/256
	LDA #CMD_READ_BUF
	JSR CMDDEV
	BCS READX
	SEC
	RTS

READX	CLC
	RTS


WRITES	JSR SET_BLK
	LDX #LBA		;Write BLKBUF to LBA on SD
	LDY #LBA/256
	LDA #CMD_WRITE_BUF
	JSR CMDDEV
	BCS READX
	SEC
	RTS


PARTD	JSR GNCHR		;GET NEXT CHR
	BCS PARTD0
	CMP #'1
	BCC PARTDX 
	CMP #'5
	BCC PARTD1
PARTDX	LDA #ILLPAR		;ILLEGAL PARAMETER
	SEC
	RTS

PARTD0	JSR LOAD_MBR		;load MBR
	BCS PARTD0X
	JSR DISP_MBR		;display MBR data
PARTD0X	RTS

PARTD1	STA CNT_I		;save partition #
	JSR LOAD_MBR
	BCS PARTD0X
	JSR LOAD_PX		;load partition #x 
	BCS PARTD0X
	JSR DISP_PX		;display partition #x data	
	RTS


EXIT	PLA
	PLA			;back to main loop
	RTS			;return to M/OS-65


HELP	LDX #HELPM
	LDY #HELPM/256
	JSR PRTSTR
	RTS


WAIT	JSR GDEC 		;WAIT NN S
	BCS WAITX
	STA CNT
WAIT3	LDA #10
	STA MCNT 		;100 MS
WAIT2	LDX #78
WAIT1	DEY
	BNE WAIT1
	DEX
	BNE WAIT1
	DEC MCNT
	BNE WAIT2
	DEC CNT
	BNE WAIT3
	CLC
WAITX	RTS


STOBUF	JSR SET_BLK		;SAVE DMA TO BUFFER
	LDY #0
STOBU1	LDA (BLKBUF),Y
	STA (BUFFER),Y
	INY
	BNE STOBU1
	INC BLKBUF+1
	INC BUFFER+1
STOBU2	LDA (BLKBUF),Y
	STA (BUFFER),Y
	INY
	BNE STOBU2
	DEC BLKBUF+1
	DEC BUFFER+1
	CLC
	RTS


STODMA	JSR SET_BLK		;STORE BUFFER TO DMA
	LDY #0
STODM1	LDA (BUFFER),Y
	STA (BLKBUF),Y
	INY
	BNE STODM1
	INC BLKBUF+1
	INC BUFFER+1
STODM2	LDA (BUFFER),Y
	STA (BLKBUF),Y
	INY
	BNE STODM2
	DEC BLKBUF+1
	DEC BUFFER+1
	CLC
	RTS


REPEAT	LDA RCOUNT		;REPEAT COMMAND
	BEQ REPEA1
REPEA3	DEC RCOUNT		;ONE MORE TIME
	BEQ REPEA5
	LDA #0
	STA CMDVEC
	CLC
	RTS

REPEA1	JSR GDEC 		;GET NO. OF REPEATS
	BCS REPEA2
	STA RCOUNT
	CMP #0
	BNE REPEA3
	LDA #ILLPAR
REPEA4	SEC
	RTS

REPEA2	CMP #MISPAR
	BNE REPEA4
	LDA #10			;DEFAULT 10 TIMES
	STA RCOUNT
	BNE REPEA3

REPEA5	LDA #EOL
	SEC
	RTS


SETBUF	JSR GETHEX		;GET BUFFER ADDRESS
	BCS SETBUX
	STY BUFFER+1
	STA BUFFER
SETBUX	RTS


;======  SUBROUTINES  ============== 

LOAD_MBR			;load MBR
	LDA #0
	LDX #3			;reset LBA, BASE, N32
LMBR1	STA LBA,X
	STA BASE,X
	STA P_BASE,X
	STA FAT_LEN,X
	STA FAT_BASE,X
	STA N32,X
	DEX
	BPL LMBR1
	JSR READS		;read sector 0 to BLKBUF
	RTS


DISP_MBR			;display partition data
	LDA #BLKB+$1BE	;set PNT to partition table
	STA PNT
	LDA #BLKB+$1BE/256
	STA PNT+1
	LDX #P_HEAD		;display header
	LDY #P_HEAD/256
	JSR PRTSTR
	LDA #1			;set partition # = 1
	STA MCNT
DMBR01	LDX #2			;display partition data
	JSR XSP			;display y spaces
	LDA MCNT
	JSR DISHEX		;display partition #
	LDX #6
	JSR XSP
	LDY #0			;display boot flag
	LDA (PNT),Y
	JSR DISHEX
	LDX #4
	JSR XSP
	LDY #4			;display partition type
	LDA (PNT),Y
	JSR DISHEX
	LDX #4
	JSR XSP
	LDY #8+3
DMBR02	LDA (PNT),Y		;display partition start
	JSR PRTHEX
	DEY
	CPY #8
	BCS DMBR02
	LDX #2
	JSR XSP
	LDY #12+3
DMBR03	LDA (PNT),Y		;display partition length
	JSR PRTHEX
	DEY
	CPY #12
	BCS DMBR03
	JSR CRLF
	LDA #$10
	CLC
	ADC PNT
	STA PNT
	BCC DMBR04
	INC PNT+1
DMBR04	INC MCNT
	LDA #4
	CMP MCNT
	BCS DMBR01
	RTS


LOAD_PX	LDA CNT_I		;set LBA to Partition #x
	STA PXMES1A		;store part# in message
	AND #$07
	TAY
	DEY
	BEQ LOADPX2
	CLC
	LDA #0			;calc offest for MBR partition table
LOADPX1	ADC #16
	DEY
	BNE LOADPX1
	TAY
LOADPX2	LDX #0
LOADPX3	LDA BLKB+$1BE+8,Y
	STA BASE,X		;BASE = begin of partition
	STA P_BASE,X
	STA LBA,X		;LBA = begin of partition
	INY
	INX
	CPX #4
	BCC LOADPX3
	TYA
	PHA
LOADPX6	LDA BLKB+$1BE+8,Y	;save partition length
	STA P_BASE,X
	INY
	INX
	CPX #8
	BCC LOADPX6
	PLA
	TAY
	JSR CHK_PART		;check if this is a partition
	BCS LOADPXX
	JSR READS
	BCS LOADPXX
	LDA BLKB+$11		;save # dir entries
	STA NDIR
	LDA BLKB+$12
	STA NDIR+1
	LDA BLKB+$0D		;save # sectors/cluster
	STA SEC_CLUS
	LDA BLKB+$0E		;N32 = #reserved sectors
	STA N32
	STA RES_SEC
	LDA BLKB+$0F
	STA N32+1
	STA RES_SEC+1
	JSR ADD			;BASE = BASE + N32
	LDX #3
LOADPX7	LDA BASE,X		;save FAT base
	STA FAT_BASE,X
	DEX
	BPL LOADPX7
	LDA BLKB+$10
	STA NFAT		;#FATs
	STA NFAT_B
	LDA BLKB+$15
	STA MEDIA_BYTE		;media byte
	LDA #$16
	STA FAT_TYPE		;set FAT16
	LDA BLKB+$16		;N32 = FAT size
	STA N32
	STA FAT_LEN
	LDA BLKB+$17
	STA N32+1
	STA FAT_LEN+1
	ORA N32			;N32 = 0? -> FAT32
	BEQ LOADPX4
	JSR CHK_FAT12
	BCS LOADPX5		;FAT16?
	LDA #$12
	STA FAT_TYPE		;set FAT12

LOADPX5	JSR ADD
	DEC NFAT
	BNE LOADPX5
	JSR DIRB2LBA		;set LBA = BASE
	JSR READS		;READ SECTOR
LOADPXX	RTS

LOADPX4	LDA BLKB+$24		;N32 = FAT32 size
	STA N32
	STA FAT_LEN
	LDA BLKB+$25
	STA N32+1
	STA FAT_LEN+1
	LDA BLKB+$26
	STA N32+2
	STA FAT_LEN+2
	LDA BLKB+$27
	STA N32+3
	STA FAT_LEN+3
	LDA #$32
	STA FAT_TYPE		;set FAT32
	JMP LOADPX5


DISP_PX				;display partition #x data
	LDX #PX_MES1		;display partx header
	LDY #PX_MES1/256
	JSR PRTSTR
	LDA #P_BASE		;print partition base
	STA PNT
	LDA #P_BASE/256
	STA PNT+1
	JSR DIS32
	LDX #PX_MES2		;display partx length
	LDY #PX_MES2/256
	JSR PRTSTR
	LDA #P_LEN		;print partition length
	STA PNT
	LDA #P_LEN/256
	STA PNT+1
	JSR DIS32
	LDX #PX_MES3		;display partx media byte
	LDY #PX_MES3/256
	JSR PRTSTR
	LDA MEDIA_BYTE
	JSR DISHEX
	LDX #PX_MES4		;display FAT type
	LDY #PX_MES4/256
	JSR PRTSTR
	LDA FAT_TYPE
	JSR DISHEX
	LDX #PX_MES5		;display sec/cluster
	LDY #PX_MES5/256
	JSR PRTSTR
	LDA SEC_CLUS
	JSR DISHEX
	LDX #PX_MES6		;display reserved sectors
	LDY #PX_MES6/256
	JSR PRTSTR
	LDA RES_SEC
	LDY RES_SEC+1
	JSR DIS16
	LDX #PX_MES7		;display #FATs
	LDY #PX_MES7/256
	JSR PRTSTR
	LDA NFAT_B
	JSR DISHEX
	LDX #PX_MES8		;display FAT length
	LDY #PX_MES8/256
	JSR PRTSTR
	LDA #FAT_LEN		;print FAT base
	STA PNT
	LDA #FAT_LEN/256
	STA PNT+1
	JSR DIS32
	LDX #PX_MES9		;display FAT base
	LDY #PX_MES9/256
	JSR PRTSTR
	LDA #FAT_BASE		;print FAT base
	STA PNT
	LDA #FAT_BASE/256
	STA PNT+1
	JSR DIS32
	LDX #PX_MESA		;display root DIR base
	LDY #PX_MESA/256
	JSR PRTSTR
	LDA #LBA		;print FAT base
	STA PNT
	LDA #LBA/256
	STA PNT+1
	JSR DIS32
	JSR CRLF
	CLC
	RTS


ADD	CLC			;BASE = BASE + N32
	LDX #0
	LDY #3
ADD1	LDA BASE,X
	ADC N32,X
	STA BASE,X
	INX
	DEY
	BPL ADD1
	RTS


DIRB2LBA			;set LBA = BASE
	LDX #3
DIRB2L1	LDA BASE,X
	STA LBA,X
	DEX
	BPL DIRB2L1
	RTS


CHK_PART			;check for no partition
	LDX #3
CHKP2	LDA BLKB+$1BE+8,Y
	BNE CHKP1		;partition length >0?
	INY
	DEX
	BPL CHKP2
	LDA #NO_PART
	SEC
	RTS

CHKP1	CLC
	RTS

CHK_FAT12			;check for FAT12
	LDA P_LEN+2
	BNE CHKF12
	LDA P_LEN+1
	CMP #$80
	RTS			;C = 1 FAT12

CHKF12	SEC
	RTS


DIS32	LDY #3
DIS32A	LDA (PNT),Y		;display 32 bit (PNT) H-->L
	JSR PRTHEX
	DEY
	BPL DIS32A
	BMI DISHEX1

DIS16	PHA			;display A/Y L/H
	TYA
	JSR PRTHEX
	PLA			

DISHEX	JSR PRTHEX		;DISPLAYS A HEX
DISHEX1	LDA #SPACE
	JSR PRTCHR
	RTS


DISASC	AND #$7F
	CMP #$20
	BCC DISAS1
	CMP #$7F
	BCC DISAS2
DISAS1	LDA #'.
DISAS2	JSR PRTCHR
	RTS


GDEC	JSR GETHEX		;GETS A DECIMAL FROM LINE
	BCS GDECX
	AND #$0F
	CMP #10
	BCS GDEC1
	STA NUMBER		;EINER
	LDA HEXL
	AND #$F0
	LSR A			;ZEHNER*8
	PHA
	CLC
	ADC NUMBER
	STA NUMBER
	PLA
	LSR A
	LSR A			;ZEHNER*2
	CLC
	ADC NUMBER
	CPY #3			;Y= HEXH
	BCS GDEC1
GDEC5	DEY
	BMI GDEC4
	ADC #100
	BCC GDEC5
GDEC1	LDA #ILLPAR
	SEC
GDECX	RTS

GDEC4	STA NUMBER
	CLC
	RTS


GETLBA	JSR GETHEX		;get sector nr
	BCS GETHEX1
	LDX #3
GETSEC2	LDA HEXL,X		;copy HEX -> LBA
	STA LBA,X
	DEX
	BPL GETSEC2
GETHEX1	RTS


GETHEX	LDA #0			;GET 32 bit HEX NUMBER FROM LINE
	LDX #3			;reset HEX
GETHEX8	STA HEXL,X
	DEX
	BPL GETHEX8
	TAX
GETHE2	JSR GETNIB		;GET NIBBLE TO HEX
	BCS GETHE1
	INX
	CPX #9
	BCC GETHE2
GETHE5	LDA #ILLPAR		;ILLEGAL PARAMETER
	SEC
	RTS

GETHE1	CPX #0
	BNE GETHE3
	CMP #SPACE
	BEQ GETHE2
	CMP #EOL
	BEQ GETHE6
	CMP #SEMI
	BNE GETHE5
GETHE6	LDA #MISPAR
	SEC
	RTS

GETHE3	CMP #SEMI
	BEQ GETHE4
	CMP #',
	BEQ GETHE4
	CMP #EOL
	BNE GETHE5
GETHE4	LDA HEXL
	LDY HEXH
	CLC
	RTS


GETNIB	JSR GNCHR		;GET NIBBLE TO HEX
	BCS GETNIX
	CMP #'0
	BCC GETNI1
	CMP #$3A
	BCC GETNI2
	CMP #'A
	BCC GETNI1
	CMP #'G
	BCC GETNI3
GETNI1	SEC
GETNIX	RTS

GETNI3	CLC
	ADC #9
GETNI2	AND #$0F
	LDY #4
GETNI4	ASL HEXL
	ROL HEXH
	ROL HEXX
	DEY
	BNE GETNI4
	ORA HEXL
	STA HEXL
	CLC
	RTS


GNCHR	LDY #0
	INC CMDVEC
	LDA CMDVEC
	CMP (INBUF),Y
	BCS GNCHRX
	TAY
	LDA (INBUF),Y
	JSR UPCASE
	CLC
	RTS

GNCHRX	LDA #EOL
	RTS


UPCASE	CMP #'a			;LOWER --> UPPER CASE
	BCC UPCASX
	CMP #'~
	BCS UPCASX
	AND #$5F
UPCASX	RTS


;********************************************

ERROR	STA ERRNO		;ERROR ROUTINE
	JSR CRLF
	LDA #ERRTAB		;SET CCPV
	STA CCPV
	LDA #ERRTAB/256
	STA CCPV+1
	LDY #0			;CHECK ERROR CODE
	LDA (CCPV),Y
ERROR1	BEQ ERROR4		;END OF ERROR ROUTINE
	CMP ERRNO
	BEQ ERROR3
ERROR2	JSR INCCPV		;SKIP ERROR MESSAGE
	BNE ERROR2
	JSR INCCPV
	JMP ERROR1

ERROR3	JSR INCCPV
	PHA
	JSR ERRTYP		;PRINT ERROR TYPE
	JSR INCCPV
	LDX CCPV 		;PRINT ERROR MESSAGE
	LDY CCPV+1
	JSR PRTSTR
	PLA
	BPL ERROR5
	JSR ASKRTY		;ASK FOR RETRY
	LDA ERRNO
	RTS

ERROR4	JSR UETYP		;UNKNOWN ERROR
ERROR5	SEC
	RTS


ERRTYP	LDY #0			;PRINT ERROR TYPE
ERRTY1	LSR A			;SHIFT SOURCE BIT IN C
	BCS ERRTY2
	INY			;X= X+5
	INY
	INY
	INY
	INY
	BNE ERRTY1

ERRTY2	LDA ETYPTB,Y
	BEQ UETYP		;LAST CHR?
	JSR PRTCHR
	INY
	BNE ERRTY2

UETYP	LDX #ERRM1
	LDY #ERRM1/256
	JSR PRTSTR
	LDA ERRNO
	JSR PRTHEX

CRLF	LDA #CR			;PRINTS A NEWLINE
	JMP PRTCHR


XSP	LDA #SPACE
XSP1	JSR PRTCHR
	DEX
	BNE XSP1
	RTS


PRTSTR	STX PSTR		;print string EOSZ
	STY PSTR+1
	LDY #0
PRTSTR1	LDA (PSTR),Y
	BEQ PRTSTRX		;$00 reached?
	JSR COUT
	INY
	BNE PRTSTR1
	INC PSTR+1
	BNE PRTSTR1

PRTSTRX	CLC
	RTS



PRTCHR	JMP COUT		;PRINTS A CHR


INCCPV	INC CCPV 		;INC CCPV
	BNE INCCP1
	INC CCPV+1
INCCP1	LDA (CCPV),Y
	RTS


ASKRTY	LDX #RTYMES		;RETRY?
	LDY #RTYMES/256
	JSR PRTSTR
	JSR CIN
	JSR UPCASE
	CMP #'Y
	BNE ASKRT1
	CLC
	RTS

ASKRT1	SEC
	RTS


PRTHEX	PHA			;PRINTS A HEX NUMBER
	LSR A
	LSR A
	LSR A
	LSR A
	JSR PRTNIB		;PRINT NIBBLE
	PLA
	AND #$0F

PRTNIB	CMP #$0A
	BCC PRTNI1
	ADC #6
PRTNI1	ADC #$30
	JSR PRTCHR
	RTS


ERRM1	DB ' Error $',EOT
RTYMES	DB CR,LF,'Retry	(Y/N) ? ',EOT

ETYPTB	DB 'BIOS',$00,'BDOS',$00,'CCP',$00,$00
	DB 'RSX',$00,$00,'USER',$00

ERRTAB	DB $F9,$01,'Invalid Drive',EOT
	DB $DE,$82,'Directory full',EOT
	DB $DD,$82,'File not found',EOT
	DB $DC,$02,'File exists',EOT
	DB $D8,$82,'Disk full',EOT
	DB $D6,$82,'File is R/O',EOT
	DB $8B,$10,'no image available',EOT
	DB $8A,$10,'too many IMG files',EOT
	DB $89,$10,'no partition found',EOT
	DB $88,$10,'no SD card found',EOT
	DB $87,$10,'SD card changed',EOT
	DB $86,$10,'SD card write protected',EOT
	DB $85,$10,'Invalid Drive',EOT
	DB $84,$10,'End of Line',EOT
	DB $83,$10,'Too Much Parameters',EOT
	DB $82,$10,'Illegal Parameter',EOT
	DB $81,$10,'Missing Parameter',EOT
	DB $80,$10,'Unknown Command',EOT

	DB $00

;--- Disk Image TABLE ---

SD_TYPE	DB 0		;SD Card Type

IMG_SIZ	DB 0,0,$10,0	;image size 1 MB
MINUS_2	DB $FE,$FF,$FF,$FF	;-2

;--------------

BANNER	DB CR,CR,'SD-EDIT V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30,CR,EOT

STATM1	DB CR,'SD-EDIT V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
	DB '  SD-Drive',EOT

STATM2	DB ':  Sector ', EOT

STATM3	DB '   LBA ',EOT

P_HEAD	DB CR,'Part#   Bootflag  Type     Begin    Length',CR,EOT

PX_MES1	DB CR,'Partition # '
PXMES1A	DB '1',CR,'           Begin: ',EOT
PX_MES2	DB '   Length: ',EOT
PX_MES3	DB CR,'      Media Byte: ',EOT
PX_MES4 DB '         FAT',EOT
PX_MES5	DB '      Sectors/Cluster: ',EOT
PX_MES6	DB CR,'Reserved Sectors: ',EOT
PX_MES7	DB '    # of FATs: ',EOT
PX_MES8	DB '      FAT Length: ',EOT
PX_MES9	DB CR,'        FAT Base: ',EOT
PX_MESA	DB '                 Root Dir Base: ',EOT

PROMPT	DB CR,'Command >',EOT

HELPM	DB CLS,'   SD-EDIT V',VERSION/16+$30,'.',VERSION*$1000/$1000+$30
	DB '			(c) 18.7.2023',CR
	DB 'Command Summary:',CR
	DB ' D	dump current Sector	'
	DB ' Lnnnnnn  read LBA nnnnnn	',CR
	DB ' +	read next sector	'
	DB ' -	read last sector',CR
	DB ' R	read current sector	'
	DB ' W	write current sector',CR
	DB ' P	show partition data	'
	DB ' Znn	wait for nn s   ',CR
	DB ' >	save sector to buffer   '
	DB ' <	get sector from buffer',CR
	DB ' Baddr set buffer to addr	'
	DB ' /nn	repeat nn times',CR
	DB ' CHad,by,by,...	change value at ad with by',CR
	DB ' CAad,<string>	change at ad with string',CR
	DB ' ?	prints this screen	'
	DB ' ',SEMI,'	command separator',CR
	DB ' X	exit to CP/M		',CR
	DB EOT


IMG_LBA				;Image LBAs

	END
